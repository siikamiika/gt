#!/usr/bin/env python3
import os
import sys
import argparse
import gt
from html import unescape as html_unescape

def parse_colors(colors):
    """
    Creates a dictionary from a string of 'key=value' segments delimited
    by ':', simply ignoring segments that don't contain '='.
    """
    return dict(kv.split('=', 1) for kv in colors.split(':') if '=' in kv)

def term_ansi_capable():
    """
    Checks if the terminal is ANSI-capable.
    """
    return os.getenv('TERM') not in [None, '', 'dumb']

def stream_ansi_capable(stream):
    """
    Checks if a stream is ANSI-capable.
    """
    return hasattr(stream, 'isatty') and stream.isatty()

DEFAULT_COLORS = 'no=1;33:tr=32:sp=1;34:tv=1;31:os=:he=1;32:ex=33:bo=1;4:co=1;4:ss=1;31'

def main():
    parser = argparse.ArgumentParser(
        formatter_class=argparse.RawTextHelpFormatter,
        description='''CLI Google Translate client

environment variables:

    GT_COLORS
        overrides the default colors and other attributes used to highlight
        various parts of the output. Its value is a colon-separated list of
        part=attributes pairs that defaults to
            ''' + DEFAULT_COLORS + '''

        The following parts of output are supported:
            no  notice
            tr  transliteration
            sp  speech part name
            tv  translation variant
            os  synonym in original language (with -x/--extended)
            he  header
            ex  usage example in the context of a definition
            bo  "bold" text used to highlight the word in an example
            co  correction highlight
            ss  source segment (with -S/--segments)

"text" arguments handling and the interactive mode:

    If multiple "text" arguments are given, they are joined by space; that means
    you don't need to quote phrases, i.e. you can type
        $ gt en de get out
    instead of
        $ gt en de 'get out'
    Beware of your shell metacharacters, though.

    If no "text" arguments given, the program will start in the interactive
    mode. You can quit it by sending an EOF (typically Ctrl+D).
''')

    parser.add_argument('-T', '--source-translit',
                        action='store_true',
                        help='show source transliteration')

    parser.add_argument('-t', '--translit',
                        action='store_true',
                        help='show translation transliteration')

    verbosity = parser.add_mutually_exclusive_group()
    verbosity.add_argument('-r', '--result-only',
                           action='store_true',
                           help='do not show translation variants of a given '
                                'word')

    verbosity.add_argument('-x', '--extended',
                           action='store_true',
                           help='show synonyms in source language for each '
                                'translation variant')

    parser.add_argument('-S', '--segments',
                        action='store_true',
                        help='show translation of each text segment')

    parser.add_argument('-e', '--examples',
                        action='store_true',
                        help='show usage examples of a given word')

    parser.add_argument('-d', '--definitions',
                        action='store_true',
                        help='show definitions of a given word')

    parser.add_argument('-a', '--see-also',
                        action='store_true',
                        help='show the "see also" list for a given word')

    parser.add_argument('-s', '--synonyms',
                        action='store_true',
                        help='show synonym list for a given word')

    parser.add_argument('-c', '--correct',
                        action='store_true',
                        help='auto-correct the original text (or transcribe to '
                             'a different writing system)')

    parser.add_argument('-l', '--suggest-lang',
                        action='store_true',
                        help='suggest original language(s)')

    parser.add_argument('-R', '--ratings',
                        action='store_true',
                        help='show translation ratings (only makes sense with '
                             '-x/--extended)')

    parser.add_argument('-L', '--interface-lang',
                        help='specify the interface language (that is, language'
                             ' of speech part names)')

    parser.add_argument('source_lang',
                        help='source language code, or \'auto\' to auto-detect')
    parser.add_argument('target_lang',
                        help='target language code')
    parser.add_argument('text',
                        nargs='*',
                        help='text to translate')

    args = parser.parse_args()

    ansi_capable = stream_ansi_capable(sys.stdout) and term_ansi_capable()

    colors = parse_colors(DEFAULT_COLORS)
    colors.update(parse_colors(os.getenv('GT_COLORS', '')))

    def colorize(color, text):
        """
        Wraps text with ANSI escapes corresponding to given "part of output" if
        ansi_capable flag is set, or returns unmodified text otherwise.
        """
        if ansi_capable:
            return '\033[{}m{}\033[0m'.format(colors[color], text)
        return text

    def colorize_between(color, begin, end, text, alt_begin='*', alt_end='*'):
        """
        Wraps segments of 'text' between 'begin' and 'end' with ANSI escapes
        corresponding to given "part of output" if ansi_capable flag is set, or
        wraps them with 'alt_begin' and 'alt_end' otherwise.
        If unmatched 'begin' on the end of 'text' is detected, the reset ANSI
        escape or 'alt_end' is inserted to the end.
        """
        if ansi_capable:
            color_begin, color_end = '\033[{}m'.format(colors[color]), '\033[0m'
        else:
            color_begin, color_end = alt_begin, alt_end
        result = text.replace(begin, color_begin).replace(end, color_end)
        if text.rfind(begin) > text.rfind(end):
            result += color_end
        return result

    def build_bar(level, width, blocks=' ▏▎▍▌▋▊▉█'):
        """
        Builds a text bar.
        Args:
            level: the ratio of the 'filled' part to the whole; must belong to
                [0; 1]
            width: bar width in symbols
            blocks: symbols to use, from 'empty' to 'filled up'
        """
        if level < 0 or level > 1:
            raise ValueError('level must belong to [0; 1]')
        if width <= 0:
            raise ValueError('width must be positive')
        if not blocks:
            raise ValueError('blocks are empty')
        fullblocks = int(width * level)
        start = blocks[-1] * fullblocks
        if fullblocks == width:
            return start
        end = blocks[0] * (width - fullblocks - 1)
        middle_index = round((width * level - fullblocks) * (len(blocks)-1))
        return start + blocks[middle_index] + end

    def get_translation(source_lang, target_lang, text):
        return gt.get_translation(
            source_lang, target_lang, text,
            include_translit=args.translit or args.source_translit,
            include_variants=not args.result_only,
            include_segments=args.segments,
            include_examples=args.examples,
            include_definitions=args.definitions,
            include_see_also=args.see_also,
            include_synonyms=args.synonyms,
            suggest_language=args.suggest_lang,
            correct_typos=args.correct,
            interface_lang=args.interface_lang)

    def print_translation(translation):
        if translation.correction.corrected_text:
            if translation.correction.corrected_html:
                highlighted = html_unescape(colorize_between(
                    'co', '<b><i>', '</i></b>',
                    translation.correction.corrected_html))
                print('{} {}'.format(
                    colorize('no', 'Text was corrected:'),
                    highlighted))
            else:
                print('{} {}'.format(
                    colorize('no', 'Text was changed to:'),
                    translation.correction.corrected_text))

            translation = get_translation(args.source_lang, args.target_lang,
                                          translation.correction.corrected_text)

        if not translation.source_lang:
            print(colorize('no',
                           'Seems that this source language is not supported.'))

        if args.source_lang == 'auto':
            print(colorize('no', 'Language detected: {}'.format(
                translation.source_lang)))

        if args.suggest_lang:
            lang_suggests = [s.language for s in translation.lang_suggests]
            if not lang_suggests:
                print(colorize('no', 'No languages were suggested'))
            elif lang_suggests != [translation.source_lang]:
                print(colorize('no', 'Language(s) suggested: {}'.format(
                    ', '.join(lang_suggests))))

        if args.source_translit and translation.original_translit:
            print(colorize('tr', translation.original_translit))

        if translation.segments:
            for segment in translation.segments:
                if (not segment.translations or
                        segment.translations[0] == segment.original_segment):
                    print(segment.original_segment)
                else:
                    print('{}\n  {}'.format(
                        segment.translations[0],
                        colorize('ss', segment.original_segment)))
        else:
            print(translation.translation)

        if args.translit and translation.translation_translit:
            print(colorize('tr', translation.translation_translit))

        for group in translation.variant_groups:
            if args.extended:
                print(' {}:'.format(colorize('sp', group.speech_part)))
                for variant in group.variants:
                    if args.ratings:
                        if variant.weight is not None and group.max_weight:
                            level = variant.weight / group.max_weight
                        else:
                            level = 0
                        tab = build_bar(level, 3)
                    else:
                        tab = '  '
                    print('{}{}: {}'.format(
                        tab,
                        colorize('tv', variant.translation),
                        colorize('os', ', '.join(variant.synonyms))))
            else:
                variants = (v.translation for v in group.variants)
                print(' {}: {}'.format(
                    colorize('sp', group.speech_part),
                    colorize('tv', ', '.join(variants))))

        if translation.examples:
            print('\n{}:'.format(colorize('he', 'Examples')))
            for example in translation.examples:
                print(' {}'.format(html_unescape(colorize_between(
                    'bo', '<b>', '</b>', example.example_html))))

        if translation.definition_groups:
            print('\n{}:'.format(colorize('he', 'Definitions')))
            for group in translation.definition_groups:
                print(' {}:'.format(colorize('sp', group.speech_part)))
                for definition in group.definitions:
                    if definition.example:
                        print('  {} -- {}'.format(
                            definition.definition,
                            colorize('ex', definition.example)))
                    else:
                        print('  {}'.format(definition.definition))

        if translation.synonym_groups:
            print('\n{}:'.format(colorize('he', 'Synonyms')))
            for group in translation.synonym_groups:
                print(' {}: {}'.format(
                    colorize('sp', group.speech_part),
                    ', '.join(group.synonyms)))

        if translation.see_also:
            print('\n{}:'.format(colorize('he', 'See also')))
            print(' {}'.format(', '.join(translation.see_also)))


    if args.text:
        translation = get_translation(args.source_lang, args.target_lang,
                                      ' '.join(args.text))
        print_translation(translation)
    else:
        try:
            # input() uses readline if and only if this module is loaded.
            import readline # pylint: disable=unused-variable
        except ImportError:
            pass
        while True:
            text = None
            try:
                text = input('> ')
            except EOFError:
                break
            translation = get_translation(args.source_lang, args.target_lang,
                                          text)
            print_translation(translation)
        # Print a newline so that shell prompt that will appear on the next line
        # will not be messed up with our prompt.
        print()

if __name__ == '__main__':
    main()
