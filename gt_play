#!/usr/bin/env bash

# TAKES:
#     $1 - text
# PRINTS:
#     URL-encoded text
urlencode() {
    local LC_ALL=C # Forces splitting strings by bytes, not by Unicode symbols
    local symbol result
    local -i i len=${#1}
    for (( i = 0; i < len; ++i )); do
        symbol=${1:$i:1}
        if [[ $symbol != [-_.~a-zA-Z0-9] ]]; then
            printf -v symbol '%%%02X' "'$symbol"
        fi
        result+=$symbol
    done
    printf '%s\n' "$result"
}

# TAKES:
#     $1 - language code
#     $2 - text
#     $3 - encoding
# PRINTS:
#     voice URL
get_voice_url() {
    local text=$2
    if (( ${#text} > 100 )); then
        echo >&2 "W: text is too big (${#text}/100), cutting down."
        text=${text:0:100}
    fi
    text=$(urlencode "$text")
    # Hopefully no need in URL-encoding these two...
    local enc=$3
    local lang=$1

    printf '%s\n' \
        "http://translate.google.com/translate_tts?ie=$enc&tl=$lang&q=$text"
}

# TAKES:
#     $@ - binary names
# PRINTS:
#     first binary name found in PATH
# RETURNS:
#     0 - if a binary was found and printed
#     1 - otherwise
select_binary() {
    local binary
    for binary; do
        hash -- "$binary" 2>/dev/null || continue
        printf '%s\n' "$binary"
        return
    done
    return 1
}

################################################################################

usage() {
    cat >&2 <<EOF
USAGE: ${0##*/} [-gd] [-p PLAYER] [-e ENCODING] [--] LANG TEXT [TEXT...]

If multiple TEXT arguments are given, they are joined by space.

OPTIONS:
    -g: print voice URL, do not play
    -g: download, do not play
    -p: specify a player (default: guess from \$PLAYER, mpv, mplayer2, mplayer)
    -e: specify TEXT encoding (default: UTF-8)

EXAMPLES:
    ${0##*/} en party; ${0##*/} en_US party
EOF
    exit 2
}

# TAKES:
#     $1 - language code
#     $2 - text
#     $3 - encoding
# RETURNS:
#     0 - if everything is OK
#    >0 - if no downloaders were found or if a downloader failed
download() {
    local -a downloader
    # Replace all slashes with underscores
    local filename=${2//\//_}.mp3
    local useragent='Mozilla/5.0'

    if hash wget 2>/dev/null; then
        downloader=( wget -nv -O"$filename" -U"$useragent" )
    elif hash curl 2>/dev/null; then
        downloader=( curl -# -o"$filename" -A"$useragent" )
    else
        echo >&2 'E: neither wget nor curl were found.'
        return 1
    fi

    "${downloader[@]}" "$(get_voice_url "$@")"
}

# TAKES:
#     $1 - language code
#     $2 - text
#     $3 - encoding
# RETURNS:
#     0 - if everything is OK
#    >0 - if $player is empty and can't be auto-detected or if it failed
play() {
    # if "-p" wasn't passed...
    if [[ ! -v player ]]; then
        # If $PLAYER is set and not empty, grab it
        # shellcheck disable=SC2153
        if [[ -n $PLAYER ]]; then
            player=( $PLAYER )
        else
            # Try to guess player
            local binary
            if binary=$(select_binary mpv mplayer2 mplayer); then
                # If mpv was chosen by select_binary, and it supports
                # '--no-ytdl' option, pass it.
                if [[ $binary == mpv ]] && \
                    mpv --no-ytdl >/dev/null 2>/dev/null;
                then
                    player=( mpv --no-ytdl )
                else
                    player=( "$binary" )
                fi
            else
                echo >&2 "E: cannot auto-detect player."
                return 1
            fi
        fi
    fi
    "${player[@]}" "$(get_voice_url "$@")"
}

action=play
unset player
encoding=UTF-8

while getopts 'gdp:e:' option; do
    case "$option" in
        g) action=get_voice_url ;;
        d) action=download ;;
        p) player=( $OPTARG ) ;;
        e) encoding=$OPTARG ;;
        *) usage ;;
    esac
done

# Drop processed arguments
shift "$(( OPTIND - 1 ))" || usage

# Now, the first argument is LANG and the rest is TEXT.
# At least one TEXT argument is required.
(( $# < 2 )) && usage

# "$*" joins arguments by the first symbol of $IFS. We save old $IFS to restore
# it later.
old_ifs=$IFS
# Join TEXT arguments by space. "${*:2}" joins arguments starting with the
# second.
IFS=' '
joined_text=${*:2}
# Restore $IFS
IFS=$old_ifs

"$action" "$1" "$joined_text" "$encoding"
