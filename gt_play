#!/usr/bin/env bash

# This is needed for select_binary_ and joining arguments by space with $*.
IFS=$' \t\n'

################################################################################

# Makes $_ans a reference to a variable passed as $1 and then invokes a function
# with arguments passed as the rest.
# TAKES:
#     $1 — variable name to return answer to
# [rest] — function and, optionally, arguments
ret() {
    declare -n _ans=$1
    "${@:2}"
}

################################################################################

# Checks if $1 is a name of an existent binary.
# TAKES:
#     $1 — binary name
# [rest] — (ignored)
# RETURNS:
#     0 — if $1 is a name of an existent binary
#    >0 — otherwise
has() {
    command -v -- "$@" >/dev/null 2>/dev/null
}

# Returns a first argument (as array, split by $IFS) first field of which is
# a name of an existent binary.
# TAKES:
#     $@ — commands with arguments separated by $IFS
# RETURNS:
#     0 — if binary was found
#     1 — otherwise
select_binary_() {
    local binary
    for binary; do
        if has $binary; then
            _ans=( $binary )
            return
        fi
    done
    return 1
}

# Selects a downloader. The result is an array you should append an output
# filename and an URL to.
# TAKES:
#     $1 — User-Agent
# RETURNS:
#     0 — if downloader was found
#     1 — otherwise.
select_downloader_() {
    if has wget; then
        _ans=( wget -U "$1" -O )
    elif has curl; then
        _ans=( curl -L -A "$1" -o )
    else
        return 1
    fi
}

# Makes a reasonable file name from a base and an extension.
# TAKES:
#     $1 - a base for a filename
#     $2 - extension
make_filename_() {
    local base=$1 ext=$2
    # Remove forward slashes
    base=${base//\//}
    # Remove leading dots
    base=${base##.}
    # Substitute "_" if the result is empty
    base=${base:-_}
    # Cut to 128 symbols
    base=${base:0:128}
    # Remove forward slashes
    ext=${ext//\//}
    # Cut to 8 symbols
    ext=${ext:0:8}
    # Combine
    _ans=$base.$ext
}

# URL-encodes a string.
# TAKES:
#     $1 - string
urlencode_() {
    local LC_ALL=C # Forces splitting strings by bytes, not by Unicode symbols
    local symbol result
    local -i i len=${#1}
    for (( i = 0; i < len; ++i )); do
        symbol=${1:$i:1}
        if [[ $symbol != [-_.~a-zA-Z0-9] ]]; then
            printf -v symbol '%%%02X' "'$symbol"
        fi
        result+=$symbol
    done
    _ans=$result
}

################################################################################

USERAGENT='Mozilla/5.0 (X11; Linux x86_64; rv:39.0) Gecko/20100101 Firefox/39.0'

# TAKES:
#     $1 - language code
#     $2 - text
#     $3 - encoding
get_voice_url_() {
    local lang=$1 text=$2 enc=$3
    if (( ${#text} > 100 )); then
        echo >&2 "W: text is too big (${#text}/100), cutting down."
        text=${text:0:100}
    fi
    ret text urlencode_ "$text"
    # shellcheck disable=SC2034
    _ans="http://translate.google.com/translate_tts?ie=$enc&tl=$lang&q=$text&total=1&idx=0&client=t&prev=input"
}

# TAKES:
#     $1 - language code
#     $2 - text
#     $3 - encoding
print_voice_url() {
    local url
    ret url get_voice_url_ "$@"
    printf '%s\n' "$url"
}

# TAKES:
#     $1 - language code
#     $2 - text
#     $3 - encoding
download() {
    local -a downloader
    if ! ret downloader select_downloader_ "$USERAGENT"; then
        echo >&2 "E: can't auto-detect downloader."
        return 1
    fi
    local filename url
    ret filename make_filename_ "$2" mp3
    ret url get_voice_url_ "$@"
    command -- "${downloader[@]}" "$filename" "$url"
}

# TAKES:
#     $1 - language code
#     $2 - text
#     $3 - encoding
play() {
    local tempfile
    tempfile=$(mktemp --suffix=.mp3) || return "$?"

    _cleanup_tempfile() {
        rm -- "$tempfile"
    }

    if ! ret downloader select_downloader_ "$USERAGENT"; then
        echo >&2 "E: can't auto-detect downloader."
        _cleanup_tempfile
        return 1
    fi

    local -a player
    if [[ -v option_player ]]; then
        player=( $option_player )
    else
        # shellcheck disable=SC2086,SC2153
        if ! ret player select_binary_ ${PLAYER:+"$PLAYER"} \
                 'mpv --no-ytdl' mplayer2 mplayer amarok audacious banshee \
                 clementine deadbeef exaile rhythmbox xmms mpg123 bomi dragon \
                 kaffeine parole totem vlc
        then
            echo >&2 "E: can't auto-detect player."
            _cleanup_tempfile
            return 1
        fi
    fi

    local url
    ret url get_voice_url_ "$@"

    if ! command -- "${downloader[@]}" "$tempfile" "$url"; then
        _cleanup_tempfile
        return 1
    fi
    if ! command -- "${player[@]}" "$tempfile"; then
        _cleanup_tempfile
        return 1
    fi
    _cleanup_tempfile
}

################################################################################

usage() {
    echo >&2 "\
USAGE: ${0##*/} [-gd] [-p PLAYER] [-e ENCODING] [--] LANG TEXT [TEXT...]

If multiple TEXT arguments are given, they are joined by space.

OPTIONS:
    -g: print voice URL, do not play
          NOTE: you must have a browser User-Agent to access it.
    -d: download, do not play
    -p: specify a player
    -e: specify TEXT encoding (default: UTF-8)

EXAMPLES:
    ${0##*/} en party; ${0##*/} en_US party"
    exit 2
}

option_action=play
option_encoding='UTF-8'
unset option_player

while getopts 'gdp:e:' option; do
    case "$option" in
        g) option_action=print_voice_url ;;
        d) option_action=download ;;
        p) option_player=$OPTARG ;;
        e) option_encoding=$OPTARG ;;
        *) usage ;;
    esac
done

# Drop processed arguments
shift "$(( OPTIND - 1 ))" || usage

# Now, the first argument is LANG and the rest is TEXT.
# At least one TEXT argument is required.
(( $# < 2 )) && usage

# "$*" joins arguments by the first symbol of $IFS.
"$option_action" "$1" "${*:2}" "$option_encoding"
