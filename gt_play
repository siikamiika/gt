#!/usr/bin/env bash

# TAKES:
#     $1 - text
# PRINTS:
#     URL-encoded text
urlencode() {
    local LC_ALL=C # Forces splitting strings by bytes, not by Unicode symbols
    local symbol result
    local -i i len=${#1}
    for (( i = 0; i < len; ++i )); do
        symbol=${1:$i:1}
        if [[ $symbol != [-_.~a-zA-Z0-9] ]]; then
            printf -v symbol '%%%02X' "'$symbol"
        fi
        result+=$symbol
    done
    printf '%s\n' "$result"
}

# TAKES:
#     $1 - language code
#     $2 - text
#     $3 - encoding
# PRINTS:
#     voice URL
get_voice_url() {
    local text=$2
    if (( ${#text} > 100 )); then
        echo >&2 "W: text is too big (${#text}/100), cutting down."
        text=${text:0:100}
    fi
    text=$(urlencode "$text")
    # Hopefully no need in URL-encoding these two...
    local enc=$3
    local lang=$1

    printf '%s\n' \
        "http://translate.google.com/translate_tts?ie=$enc&tl=$lang&q=$text"
}

# TAKES:
#     $@ - binary names
# PRINTS:
#     first binary name found in PATH
# RETURNS:
#     0 - if a binary was found and printed
#     1 - otherwise
select_binary() {
    local binary
    for binary; do
        hash -- "$binary" 2>/dev/null || continue
        printf '%s\n' "$binary"
        return
    done
    return 1
}

################################################################################

usage() {
    cat >&2 <<EOF
USAGE: ${0##*/} [-gd] [-p PLAYER] [-e ENCODING] [--] LANG TEXT [TEXT...]

If multiple TEXT arguments are given, they are joined by space.

OPTIONS:
    -g: print voice URL, do not play
    -g: download, do not play
    -p: specify a player (default: guess from \$PLAYER, mpv, mplayer2, mplayer)
    -e: specify TEXT encoding (default: UTF-8)

EXAMPLES:
    ${0##*/} en party; ${0##*/} en_US party
EOF
    exit 2
}

# TAKES:
#     $1 - language code
#     $2 - text
#     $3 - encoding
# RETURNS:
#     0 - if everything is OK
#    >0 - if no downloaders were found or if a downloader failed
download() {
    local -a downloader
    # Replace all slashes with underscores
    local filename=${2//\//_}.mp3
    local useragent='Mozilla/5.0'

    if hash wget 2>/dev/null; then
        downloader=( wget -nv -O"$filename" -U"$useragent" )
    elif hash curl 2>/dev/null; then
        downloader=( curl -# -o"$filename" -A"$useragent" )
    else
        echo >&2 'E: neither wget nor curl were found.'
        return 1
    fi

    "${downloader[@]}" "$(get_voice_url "$@")"
}

# TAKES:
#     $1 - language code
#     $2 - text
#     $3 - encoding
# RETURNS:
#     0 - if everything is OK
#    >0 - if $player is empty and can't be auto-detected or if it failed
play() {
    # Try to grab $PLAYER environment variable
    if [[ -z $player ]]; then
        # shellcheck disable=SC2153
        player=$PLAYER
    fi

    # Try to select player from $PATH
    if [[ -z $player ]]; then
        player=$(select_binary mpv mplayer2 mplayer)
        # Disable mpv's ytdl hook: if mpv was chosen by select_binary, and it
        # does support the '--no-ytdl' option, pass it.
        [[ $player == mpv ]] && mpv --no-ytdl >/dev/null 2>/dev/null \
            && player='mpv --no-ytdl'
    fi

    if [[ -z $player ]]; then
        echo >&2 "E: cannot auto-detect player."
        return 1
    fi

    local IFS=$' \t\n'
    $player "$(get_voice_url "$@")"
}

action=play
player=
encoding=UTF-8

while getopts 'gdp:e:' option; do
    case "$option" in
        g) action=get_voice_url ;;
        d) action=download ;;
        p) player=$OPTARG ;;
        e) encoding=$OPTARG ;;
        *) usage ;;
    esac
done

# Drop processed arguments
shift "$(( OPTIND - 1 ))" || usage
# Now, the first argument is LANG and the rest is TEXT.
# At least one TEXT argument is required.
(( $# < 2 )) && usage
lang=$1
shift
# Now all arguments are TEXT.
# "$*" joins arguments by the first symbol of $IFS.
IFS=' '
"$action" "$lang" "$*" "$encoding"
