#!/usr/bin/env bash

# TAKES:
#     $@ - binary names
# PRINTS:
#     first binary name found in PATH
# RETURNS:
#     0 - if a binary was found and printed
#     1 - otherwise
select_binary() {
    local binary
    for binary; do
        hash -- "$binary" 2>/dev/null || continue
        printf '%s\n' "$binary"
        return
    done
    return 1
}

# SETS:
#     player - player binary and arguments
# RETURNS:
#     0 - if player was detected
#     1 - otherwise
guess_player() {
    # shellcheck disable=SC2153
    if [[ -n $PLAYER ]]; then
        player=( $PLAYER )
    else
        local binary
        if binary=$(select_binary mpv mplayer2 mplayer); then
            if [[ $binary == mpv ]] && mpv --no-ytdl >/dev/null 2>/dev/null
            then
                player=( mpv --no-ytdl )
            else
                player=( "$binary" )
            fi
        else
            return 1
        fi
    fi
}

# SETS:
#     downloader - function that takes:
#         $1  - URL
#         $2  - output file
#        [$3] - User-Agent string
# RETURNS:
#     0 - if downloader was detected
#     1 - otherwise
guess_downloader() {
    if hash wget 2>/dev/null; then
        downloader() {
            # shellcheck disable=SC2086
            wget -O "$2" ${3+-U "$3"} "$1"
        }
    elif hash curl 2>/dev/null; then
        downloader() {
            # shellcheck disable=SC2086
            curl -L -o "$2" ${3+-A "$3"} "$1"
        }
    else
        return 1
    fi
}

# TAKES:
#     $1 - a base for a filename
#     $2 - extension
# PRINTS:
#     a valid file name
make_filename() {
    local filename=$1 extension=$2
    # Remove forward slashes
    filename=${filename//\//}
    # Remove leading dots
    filename=${filename##.}
    # Substitue "_" if the result is empty
    filename=${filename:-_}
    # Cut to 128 symbols
    filename=${filename:0:128}
    printf '%s.%s\n' "$filename" "$extension"
}

################################################################################

# TAKES:
#     $1 - text
# PRINTS:
#     URL-encoded text
urlencode() {
    local LC_ALL=C # Forces splitting strings by bytes, not by Unicode symbols
    local symbol result
    local -i i len=${#1}
    for (( i = 0; i < len; ++i )); do
        symbol=${1:$i:1}
        if [[ $symbol != [-_.~a-zA-Z0-9] ]]; then
            printf -v symbol '%%%02X' "'$symbol"
        fi
        result+=$symbol
    done
    printf '%s\n' "$result"
}

################################################################################

# TAKES:
#     $1 - language code
#     $2 - text
#     $3 - encoding
# PRINTS:
#     voice URL
get_voice_url() {
    local text=$2
    if (( ${#text} > 100 )); then
        echo >&2 "W: text is too big (${#text}/100), cutting down."
        text=${text:0:100}
    fi
    text=$(urlencode "$text")
    # Hopefully no need in URL-encoding these two...
    local enc=$3
    local lang=$1

    printf '%s\n' \
        "http://translate.google.com/translate_tts?ie=$enc&tl=$lang&q=$text"
}

# TAKES:
#     $1 - language code
#     $2 - text
#     $3 - encoding
# RETURNS:
#     0 - if everything is OK
#    >0 - if no downloaders were found or if a downloader failed
download() {
    if ! guess_downloader; then
        echo >&2 "E: can't guess downloader."
        return 1
    fi
    downloader \
        "$(get_voice_url "$@")" \
        "$(make_filename "$2" mp3)" \
        'Mozilla/5.0'
}

# TAKES:
#     $1 - language code
#     $2 - text
#     $3 - encoding
# RETURNS:
#     0 - if everything is OK
#    >0 - if $player is unset and can't be auto-detected or if it failed
play() {
    # if "-p" wasn't passed...
    if [[ ! -v player ]]; then
        if ! guess_player; then
            echo >&2 "E: can't guess player."
            return 1
        fi
    fi
    command -- "${player[@]}" "$(get_voice_url "$@")"
}

################################################################################

usage() {
    cat >&2 <<EOF
USAGE: ${0##*/} [-gd] [-p PLAYER] [-e ENCODING] [--] LANG TEXT [TEXT...]

If multiple TEXT arguments are given, they are joined by space.

OPTIONS:
    -g: print voice URL, do not play
    -g: download, do not play
    -p: specify a player (default: guess from \$PLAYER, mpv, mplayer2, mplayer)
    -e: specify TEXT encoding (default: UTF-8)

EXAMPLES:
    ${0##*/} en party; ${0##*/} en_US party
EOF
    exit 2
}

action=play
unset player
encoding=UTF-8

while getopts 'gdp:e:' option; do
    case "$option" in
        g) action=get_voice_url ;;
        d) action=download ;;
        p) player=( $OPTARG ) ;;
        e) encoding=$OPTARG ;;
        *) usage ;;
    esac
done

# Drop processed arguments
shift "$(( OPTIND - 1 ))" || usage

# Now, the first argument is LANG and the rest is TEXT.
# At least one TEXT argument is required.
(( $# < 2 )) && usage

# "$*" joins arguments by the first symbol of $IFS. We save old $IFS to restore
# it later.
old_ifs=$IFS
# Join TEXT arguments by space. "${*:2}" joins arguments starting with the
# second.
IFS=' '
joined_text=${*:2}
# Restore $IFS
IFS=$old_ifs

"$action" "$1" "$joined_text" "$encoding"
