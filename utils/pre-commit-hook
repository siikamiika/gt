#!/usr/bin/env bash

# Redirect stdout to stderr
exec 1>&2

################################################################################

empty_hash=4b825dc642cb6eb9a060e54bf8d69288fbee4904

if git rev-parse --verify HEAD >/dev/null; then
    against=HEAD
else
    against=$empty_hash
fi

modified_files=()

get_modified_files() {
    while IFS=$' \t' read -r _ _ _ _ state file; do
        if [[ $state == [AM] ]]; then
            printf '%s\n' "$file"
        fi
    done < <(git diff-index --cached "$1")
}

modified_files=( $(get_modified_files "$against") )

################################################################################

# TAKES:
#     $1 - function that check if a file should be checked with this checker
#     $2 - checker's rcfile, or an empty string
# [rest] - checker and its arguments
run_checker() {
    local function=$1; shift
    local rcfile=$1; shift
    local -a checker=( "$@" )

    local file
    local -a files
    for file in "${modified_files[@]}"; do
        if "$function" "$file"; then
            files+=( "$file" )
        elif [[ -n $rcfile && $file == "$rcfile" ]]; then
            echo "I: '$rcfile' modified, running '${checker[*]}' on *all* files."
            files=()
            for file in $(get_modified_files "$empty_hash"); do
                if "$function" "$file"; then
                    files+=( "$file" )
                fi
            done
            break
        fi
    done
    if (( ${#files[@]} )); then
        if ! "${checker[@]}" "${files[@]}"; then
            echo "E: '${checker[*]}' failed"
            exit 1
        else
            echo "I: '${checker[*]} ${files[*]}' succeed"
        fi
    else
        echo "I: not running '${checker[*]}'"
    fi
}

################################################################################

is_python_file() {
    [[ $1 == *.py ]] && return 0
    local line
    IFS= read -r line < "$1" || return 1
    [[ $line == '#!'*python* ]]
}

is_shell_file() {
    [[ $1 =~ \.(sh|bash)$ ]] && return 0
    local line
    IFS= read -r line < "$1" || return 1
    [[ $line == '#!'*sh* ]]
}

is_python_or_shell_file() {
    is_python_file "$1" || is_shell_file "$1"
}

check_non_ascii() {
    if LC_COLLATE=C grep --with-filename --color=auto '[^ -~]' -- "$@"; then
        return 1
    fi
}

run_checker is_python_file \
            utils/pylintrc \
            pylint -j3 --output-format=colorized --rcfile=utils/pylintrc --reports=no --

run_checker is_shell_file \
            "" \
            shellcheck --

run_checker is_python_or_shell_file \
            "" \
            check_non_ascii

################################################################################

if ! python3 -m unittest tests/test_doctests.py; then
    echo "E: test_doctests.py failed."
    exit 1
fi
